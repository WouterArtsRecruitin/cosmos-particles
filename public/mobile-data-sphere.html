<!DOCTYPE html>
<html lang="nl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Emergent Labs - Mobile Data Sphere</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { overflow: hidden; background: #000; font-family: 'Courier New', monospace; touch-action: none; }
        canvas { display: block; }

        #ui {
            position: absolute; top: 20px; left: 20px; color: #00f2ff;
            pointer-events: none; text-transform: uppercase; letter-spacing: 2px;
            text-shadow: 0 0 10px #00f2ff; font-size: 14px; z-index: 10;
        }

        #controls {
            position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
            color: #00f2ff88; font-size: 11px; text-transform: uppercase;
            letter-spacing: 1px; pointer-events: none; text-align: center;
            text-shadow: 0 0 8px #00f2ff; width: 90%;
        }

        #gesture-indicator {
            position: absolute; top: 20px; right: 20px; z-index: 10;
            color: #00f2ff; font-size: 14px; text-transform: uppercase;
            text-shadow: 0 0 10px #00f2ff; opacity: 0; transition: opacity 0.3s;
            pointer-events: none; letter-spacing: 2px;
        }
        #gesture-indicator.active { opacity: 1; }

        #webcam-preview {
            position: absolute; bottom: 70px; right: 20px; width: 100px; height: 75px;
            border: 1px solid #00f2ff55; border-radius: 4px; z-index: 10;
            opacity: 0.5; transform: scaleX(-1); object-fit: cover;
        }
        #video { position: absolute; width: 1px; height: 1px; opacity: 0; pointer-events: none; }

        #loading {
            position: fixed; inset: 0; background: #000; z-index: 1000;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            color: #00f2ff; transition: opacity 0.8s; letter-spacing: 2px; text-align: center; padding: 20px;
        }
        #loading.hidden { opacity: 0; pointer-events: none; }
        .spinner {
            width: 40px; height: 40px; border: 2px solid #00f2ff22;
            border-top-color: #00f2ff; border-radius: 50%;
            animation: spin 1s linear infinite; margin-bottom: 20px;
        }
        @keyframes spin { to { transform: rotate(360deg); } }
    </style>
</head>
<body>
    <div id="loading">
        <div class="spinner"></div>
        <div>INITIALIZING NEURAL CORE<br><span style="font-size:10px; opacity:0.5; margin-top:10px; display:block;">Please allow camera access</span></div>
    </div>

    <div id="ui">System: Ready</div>
    <div id="controls">HAND TRACKING ACTIVE<br>Move Hand/Swipe = Rotate | Open Palm/Tap = Explode</div>
    <div id="gesture-indicator">BIG BANG</div>

    <video id="video" autoplay playsinline webkit-playsinline muted></video>
    <video id="webcam-preview" autoplay playsinline muted></video>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/gsap.min.js"></script>

<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1675469240/hands.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils@0.3.1675466862/camera_utils.min.js"></script>

<script>
    // --- CONFIG ---
    const PARTICLE_COUNT = window.innerWidth < 768 ? 10000 : 12000;
    const GRID_SIZE = 4;
    const SPHERE_RADIUS = 5;
    const CORE_R = 1.8;
    const MID_R = 4.0;
    const OUTER_R = 7.0;
    const TIDAL_R = 8.5;
    const PALM_OPEN_THRESHOLD = 0.35;
    const FIST_THRESHOLD = 0.15;
    const BLOOM_DEFAULT = 1.8;
    const BLOOM_BANG = 15.0;
    const BLOOM_AFTER = 2.2;
    const HEARTBEAT_CYCLE = 2.8;

    let isExploded = false;
    let inputX = 0, inputY = 0;
    let targetRotX = 0, targetRotY = 0;
    let bloomTarget = BLOOM_DEFAULT;
    let prevPalmSpread = 0;

    // --- GAUSSIAN RANDOM (Box-Muller) ---
    function gaussRandom() {
        return Math.sqrt(-2 * Math.log(Math.random())) *
               Math.cos(2 * Math.PI * Math.random());
    }

    // --- HEARTBEAT FUNCTION ---
    function heartbeat(t) {
        const cycle = t % HEARTBEAT_CYCLE;
        if (cycle < 0.12) return Math.sin(cycle / 0.12 * Math.PI) * 0.06;
        if (cycle < 0.35) return 0;
        if (cycle < 0.47) return Math.sin((cycle - 0.35) / 0.12 * Math.PI) * 0.03;
        return 0;
    }

    // --- COLOUR PALETTE (5 blue variations for 3D depth) ---
    function getParticleColor() {
        const roll = Math.random();
        if (roll < 0.30) return [0.0, 0.95, 1.0];
        if (roll < 0.55) return [0.35 + Math.random() * 0.10, 0.70 + Math.random() * 0.10, 1.0];
        if (roll < 0.75) return [0.10 + Math.random() * 0.10, 0.40 + Math.random() * 0.15, 1.0];
        if (roll < 0.90) return [0.0, 0.75 + Math.random() * 0.10, 0.80 + Math.random() * 0.10];
        return [0.70 + Math.random() * 0.15, 0.88 + Math.random() * 0.07, 1.0];
    }

    // --- TEXTURE ATLAS (2048px, sharp digits) ---
    const atlasCanvas = document.createElement('canvas');
    atlasCanvas.width = 2048; atlasCanvas.height = 2048;
    const ctx = atlasCanvas.getContext('2d');
    const step = 2048 / GRID_SIZE;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    for (let i = 0; i < 10; i++) {
        const x = (i % GRID_SIZE) * step + step / 2;
        const y = Math.floor(i / GRID_SIZE) * step + step / 2;
        const fontSize = 240 + Math.random() * 80;
        ctx.font = `bold ${fontSize}px "Courier New", monospace`;
        ctx.strokeStyle = 'rgba(255,255,255,0.3)';
        ctx.lineWidth = 3;
        ctx.strokeText(i.toString(), x, y);
        ctx.fillStyle = 'white';
        ctx.fillText(i.toString(), x, y);
    }
    const atlasTexture = new THREE.CanvasTexture(atlasCanvas);
    atlasTexture.minFilter = THREE.LinearFilter;
    atlasTexture.magFilter = THREE.LinearFilter;

    // --- SCENE SETUP ---
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, innerWidth / innerHeight, 0.1, 1000);
    camera.position.z = 12;

    const renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: 'high-performance' });
    renderer.setSize(innerWidth, innerHeight);
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    document.body.appendChild(renderer.domElement);

    atlasTexture.anisotropy = renderer.capabilities.getMaxAnisotropy();

    // --- PARTICLES (King-like sphere distribution) ---
    const geometry = new THREE.PlaneGeometry(1, 1);
    const instanceUV = new Float32Array(PARTICLE_COUNT * 2);
    const particles = [];

    for (let i = 0; i < PARTICLE_COUNT; i++) {
        const digit = Math.floor(Math.random() * 10);
        instanceUV[i * 2] = (digit % GRID_SIZE) / GRID_SIZE;
        instanceUV[i * 2 + 1] = Math.floor(digit / GRID_SIZE) / GRID_SIZE;

        // King-like distribution
        const pop = Math.random();
        let r;
        if (pop < 0.50)      r = Math.abs(gaussRandom() * CORE_R);
        else if (pop < 0.80) r = Math.abs(gaussRandom() * MID_R);
        else                 r = Math.abs(gaussRandom() * OUTER_R);
        r = Math.min(r, TIDAL_R);

        const theta = Math.random() * 2 * Math.PI;
        const phi = Math.acos((Math.random() * 2) - 1);

        const x = r * Math.sin(phi) * Math.cos(theta);
        const y = r * Math.sin(phi) * Math.sin(theta);
        const z = r * Math.cos(phi);

        const len = Math.sqrt(x*x + y*y + z*z) || 1;
        const explosionForce = 0.5 + Math.random() * 1.5;

        particles.push({
            x, y, z, origX: x, origY: y, origZ: z,
            vx: (x / len) * explosionForce,
            vy: (y / len) * explosionForce,
            vz: (z / len) * explosionForce,
            scale: 0.08 + Math.random() * 0.25,
            phase: Math.random() * 0.5,
        });
    }
    geometry.setAttribute('instanceUV', new THREE.InstancedBufferAttribute(instanceUV, 2));

    const material = new THREE.MeshBasicMaterial({
        map: atlasTexture, transparent: true, blending: THREE.AdditiveBlending,
        color: 0xffffff, side: THREE.DoubleSide
    });

    material.onBeforeCompile = (shader) => {
        shader.vertexShader = `attribute vec2 instanceUV; varying vec2 vInstanceUV; ${shader.vertexShader}`.replace(
            '#include <uv_vertex>', `vInstanceUV = uv / float(${GRID_SIZE}) + instanceUV;`
        );
        shader.fragmentShader = `varying vec2 vInstanceUV; ${shader.fragmentShader}`.replace(
            '#include <map_fragment>', 'vec4 texelColor = texture2D( map, vInstanceUV ); diffuseColor *= texelColor;'
        );
    };

    const iMesh = new THREE.InstancedMesh(geometry, material, PARTICLE_COUNT);

    // Per-instance colour (5 blue populations for 3D depth)
    const tmpColor = new THREE.Color();
    for (let i = 0; i < PARTICLE_COUNT; i++) {
        const [r, g, b] = getParticleColor();
        tmpColor.setRGB(r, g, b);
        iMesh.setColorAt(i, tmpColor);
    }
    iMesh.instanceColor.needsUpdate = true;

    scene.add(iMesh);

    // --- BLOOM (lower default for sharper digits) ---
    const composer = new THREE.EffectComposer(renderer);
    composer.addPass(new THREE.RenderPass(scene, camera));
    const bloomPass = new THREE.UnrealBloomPass(
        new THREE.Vector2(innerWidth, innerHeight), BLOOM_DEFAULT, 0.4, 0.15
    );
    composer.addPass(bloomPass);

    // --- EXPLOSION LOGIC ---
    const uiEl = document.getElementById('ui');
    const gestureIndicator = document.getElementById('gesture-indicator');

    function triggerExplosion() {
        if(isExploded) return;
        isExploded = true;
        bloomTarget = BLOOM_BANG;
        uiEl.innerText = 'System: CORE_BREACH_DETECTED';
        gestureIndicator.innerText = 'BIG BANG';
        gestureIndicator.classList.add('active');
        gsap.to(bloomPass, { strength: BLOOM_BANG, duration: 0.1, onComplete: () => { bloomTarget = BLOOM_AFTER; }});
    }

    function triggerReset() {
        if(!isExploded) return;
        isExploded = false;
        bloomTarget = BLOOM_DEFAULT;
        uiEl.innerText = 'System: Re-Sequencing_Data';
        gestureIndicator.innerText = 'CORE RESETTING';
        gestureIndicator.classList.add('active');
        setTimeout(() => {
            gestureIndicator.classList.remove('active');
            if(!isExploded) uiEl.innerText = 'System: Ready | Mode: Interactive_Core';
        }, 1500);
    }

    // --- TOUCH & MOUSE FALLBACK ---
    let touchStartX = 0, touchStartY = 0;

    document.addEventListener('mousemove', (e) => {
        inputX = (e.clientX / innerWidth - 0.5) * 4;
        inputY = (e.clientY / innerHeight - 0.5) * 4;
    });

    document.addEventListener('click', () => {
        isExploded ? triggerReset() : triggerExplosion();
    });

    document.addEventListener('touchstart', (e) => {
        touchStartX = e.touches[0].clientX;
        touchStartY = e.touches[0].clientY;
    });

    document.addEventListener('touchmove', (e) => {
        inputX = (e.touches[0].clientX / innerWidth - 0.5) * 4;
        inputY = (e.touches[0].clientY / innerHeight - 0.5) * 4;
    });

    document.addEventListener('touchend', (e) => {
        if (Math.abs(e.changedTouches[0].clientX - touchStartX) < 15 &&
            Math.abs(e.changedTouches[0].clientY - touchStartY) < 15) {
            isExploded ? triggerReset() : triggerExplosion();
        }
    });

    // --- HAND TRACKING (MediaPipe) ---
    const videoEl = document.getElementById('video');
    const previewEl = document.getElementById('webcam-preview');

    const hands = new Hands({ locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1675469240/${file}` });
    hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.6, minTrackingConfidence: 0.4 });

    hands.onResults((results) => {
        if (!results.multiHandLandmarks || results.multiHandLandmarks.length === 0) return;
        const landmarks = results.multiHandLandmarks[0];

        const indexTip = landmarks[8];
        inputX = (1 - indexTip.x - 0.5) * 4;
        inputY = (indexTip.y - 0.5) * 4;

        const wrist = landmarks[0];
        const fingerTips = [landmarks[4], landmarks[8], landmarks[12], landmarks[16], landmarks[20]];
        let avgDist = 0;
        for (const tip of fingerTips) avgDist += Math.sqrt((tip.x - wrist.x)**2 + (tip.y - wrist.y)**2 + (tip.z - wrist.z)**2);
        avgDist /= fingerTips.length;

        const spreadDelta = avgDist - prevPalmSpread;
        if (avgDist > PALM_OPEN_THRESHOLD && spreadDelta > 0.03 && !isExploded) triggerExplosion();
        else if (avgDist < FIST_THRESHOLD && isExploded) triggerReset();
        prevPalmSpread = avgDist;
    });

    // --- CAMERA (force selfie with fallback) ---
    navigator.mediaDevices.getUserMedia({
        video: {
            facingMode: { exact: 'user' },
            width: { ideal: 640, max: 1280 },
            height: { ideal: 480, max: 720 },
            frameRate: { ideal: 30 }
        }
    })
    .catch(() => navigator.mediaDevices.getUserMedia({
        video: { facingMode: 'user', width: 640, height: 480 }
    }))
    .then(stream => {
        previewEl.srcObject = stream;
        videoEl.srcObject = stream;
        videoEl.play();

        async function processVideo() {
            if (videoEl.readyState >= 2) {
                await hands.send({ image: videoEl });
            }
            requestAnimationFrame(processVideo);
        }
        processVideo();

        document.getElementById('loading').classList.add('hidden');
    })
    .catch(err => {
        console.error("Camera geweigerd of niet gevonden:", err);
        document.getElementById('loading').innerHTML = `
            <div style="color:#ff4444;">CAMERA ACCESS DENIED</div>
            <div style="font-size:12px; margin-top:10px;">Touch screen to interact</div>
        `;
        setTimeout(() => document.getElementById('loading').classList.add('hidden'), 2000);
    });


    // --- ANIMATE ---
    const dummy = new THREE.Object3D();
    const clock = new THREE.Clock();

    function animate() {
        requestAnimationFrame(animate);
        const time = clock.getElapsedTime();

        // Slow rotation (3x slower than original)
        iMesh.rotation.y += 0.0006;
        iMesh.rotation.x += 0.0003;

        targetRotX += (inputX - targetRotX) * 0.05;
        targetRotY += (inputY - targetRotY) * 0.05;
        scene.rotation.y = targetRotX;
        scene.rotation.x = targetRotY;

        bloomPass.strength += (bloomTarget - bloomPass.strength) * 0.1;

        for (let i = 0; i < PARTICLE_COUNT; i++) {
            const p = particles[i];

            if (isExploded) {
                p.x += p.vx; p.y += p.vy; p.z += p.vz;
            } else {
                // Per-particle heartbeat with phase offset
                const breathScale = 1.0 + heartbeat(time + p.phase);
                p.x += (p.origX * breathScale - p.x) * 0.08;
                p.y += (p.origY * breathScale - p.y) * 0.08;
                p.z += (p.origZ * breathScale - p.z) * 0.08;
            }

            dummy.position.set(p.x, p.y, p.z);
            dummy.scale.set(p.scale, p.scale * 1.2, 1);
            dummy.quaternion.copy(camera.quaternion);
            dummy.updateMatrix();
            iMesh.setMatrixAt(i, dummy.matrix);
        }

        iMesh.instanceMatrix.needsUpdate = true;
        composer.render();
    }

    window.addEventListener('resize', () => {
        camera.aspect = innerWidth / innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(innerWidth, innerHeight);
        composer.setSize(innerWidth, innerHeight);
    });

    animate();
</script>
</body>
</html>
