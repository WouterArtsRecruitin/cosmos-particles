<!DOCTYPE html>
<html lang="nl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Emergent Labs - Mobile Data Sphere</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { overflow: hidden; background: #000; font-family: 'Courier New', monospace; touch-action: none; }
        canvas { display: block; }

        #ui {
            position: absolute; top: 20px; left: 20px; color: #00f2ff;
            pointer-events: none; text-transform: uppercase; letter-spacing: 2px;
            text-shadow: 0 0 10px #00f2ff; font-size: 14px; z-index: 10;
        }

        #controls {
            position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
            color: #00f2ff88; font-size: 11px; text-transform: uppercase;
            letter-spacing: 1px; pointer-events: none; text-align: center;
            text-shadow: 0 0 8px #00f2ff; width: 90%;
        }

        #gesture-indicator {
            position: absolute; top: 20px; right: 20px; z-index: 10;
            color: #00f2ff; font-size: 14px; text-transform: uppercase;
            text-shadow: 0 0 10px #00f2ff; opacity: 0; transition: opacity 0.3s;
            pointer-events: none; letter-spacing: 2px;
        }
        #gesture-indicator.active { opacity: 1; }

        #webcam-preview {
            position: absolute; bottom: 70px; right: 20px; width: 100px; height: 75px;
            border: 1px solid #00f2ff55; border-radius: 4px; z-index: 10;
            opacity: 0.5; transform: scaleX(-1); object-fit: cover;
        }
        #video { position: absolute; width: 1px; height: 1px; opacity: 0; pointer-events: none; }

        #loading {
            position: fixed; inset: 0; background: #000; z-index: 1000;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            color: #00f2ff; transition: opacity 0.8s; letter-spacing: 2px; text-align: center; padding: 20px;
        }
        #loading.hidden { opacity: 0; pointer-events: none; }
        .spinner {
            width: 40px; height: 40px; border: 2px solid #00f2ff22;
            border-top-color: #00f2ff; border-radius: 50%;
            animation: spin 1s linear infinite; margin-bottom: 20px;
        }
        @keyframes spin { to { transform: rotate(360deg); } }
    </style>
</head>
<body>
    <div id="loading">
        <div class="spinner"></div>
        <div>INITIALIZING NEURAL CORE<br><span style="font-size:10px; opacity:0.5; margin-top:10px; display:block;">Please allow camera access</span></div>
    </div>

    <div id="ui">System: Ready</div>
    <div id="controls">HAND TRACKING ACTIVE<br>Move Hand/Swipe = Rotate | Open Palm/Tap = Explode</div>
    <div id="gesture-indicator">BIG BANG</div>

    <video id="video" autoplay playsinline></video>
    <video id="webcam-preview" autoplay playsinline muted></video>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/gsap.min.js"></script>

<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1675469240/hands.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils@0.3.1675466862/camera_utils.min.js"></script>

<script>
    // --- CONFIG ---
    const PARTICLE_COUNT = window.innerWidth < 768 ? 4000 : 6000;
    const GRID_SIZE = 4;
    const COLOR = 0x00f2ff;
    const SPHERE_RADIUS = 5;
    const PALM_OPEN_THRESHOLD = 0.35;
    const FIST_THRESHOLD = 0.15;

    let isExploded = false;
    let inputX = 0, inputY = 0;
    let targetRotX = 0, targetRotY = 0;
    let bloomTarget = 2.5;
    let prevPalmSpread = 0;

    // --- TEXTURE ATLAS ---
    const atlasCanvas = document.createElement('canvas');
    atlasCanvas.width = 512; atlasCanvas.height = 512;
    const ctx = atlasCanvas.getContext('2d');
    const step = 512 / GRID_SIZE;
    ctx.fillStyle = 'white';
    ctx.font = 'bold 80px monospace';
    ctx.textAlign = 'center';
    for (let i = 0; i < 10; i++) {
        const x = (i % GRID_SIZE) * step + step / 2;
        const y = Math.floor(i / GRID_SIZE) * step + step / 1.3;
        ctx.fillText(i.toString(), x, y);
    }
    const atlasTexture = new THREE.CanvasTexture(atlasCanvas);

    // --- SCENE SETUP ---
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, innerWidth / innerHeight, 0.1, 1000);
    camera.position.z = 12;

    const renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: 'high-performance' });
    renderer.setSize(innerWidth, innerHeight);
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    document.body.appendChild(renderer.domElement);

    // --- PARTICLES ---
    const geometry = new THREE.PlaneGeometry(0.2, 0.2);
    const instanceUV = new Float32Array(PARTICLE_COUNT * 2);
    const particles = [];

    for (let i = 0; i < PARTICLE_COUNT; i++) {
        const digit = Math.floor(Math.random() * 10);
        instanceUV[i * 2] = (digit % GRID_SIZE) / GRID_SIZE;
        instanceUV[i * 2 + 1] = Math.floor(digit / GRID_SIZE) / GRID_SIZE;

        const r = Math.cbrt(Math.random()) * SPHERE_RADIUS;
        const theta = Math.random() * 2 * Math.PI;
        const phi = Math.acos((Math.random() * 2) - 1);

        const x = r * Math.sin(phi) * Math.cos(theta);
        const y = r * Math.sin(phi) * Math.sin(theta);
        const z = r * Math.cos(phi);

        const len = Math.sqrt(x*x + y*y + z*z) || 1;
        const explosionForce = 0.5 + Math.random() * 1.5;

        particles.push({
            x, y, z, origX: x, origY: y, origZ: z,
            vx: (x / len) * explosionForce, vy: (y / len) * explosionForce, vz: (z / len) * explosionForce
        });
    }
    geometry.setAttribute('instanceUV', new THREE.InstancedBufferAttribute(instanceUV, 2));

    const material = new THREE.MeshBasicMaterial({
        map: atlasTexture, transparent: true, blending: THREE.AdditiveBlending, color: COLOR, side: THREE.DoubleSide
    });

    material.onBeforeCompile = (shader) => {
        shader.vertexShader = `attribute vec2 instanceUV; varying vec2 vInstanceUV; ${shader.vertexShader}`.replace(
            '#include <uv_vertex>', `vInstanceUV = uv / float(${GRID_SIZE}) + instanceUV;`
        );
        shader.fragmentShader = `varying vec2 vInstanceUV; ${shader.fragmentShader}`.replace(
            '#include <map_fragment>', 'vec4 texelColor = texture2D( map, vInstanceUV ); diffuseColor *= texelColor;'
        );
    };

    const iMesh = new THREE.InstancedMesh(geometry, material, PARTICLE_COUNT);
    scene.add(iMesh);

    // --- BLOOM ---
    const composer = new THREE.EffectComposer(renderer);
    composer.addPass(new THREE.RenderPass(scene, camera));
    const bloomPass = new THREE.UnrealBloomPass(new THREE.Vector2(innerWidth, innerHeight), 2.5, 0.5, 0.1);
    composer.addPass(bloomPass);

    // --- EXPLOSION LOGIC ---
    const uiEl = document.getElementById('ui');
    const gestureIndicator = document.getElementById('gesture-indicator');

    function triggerExplosion() {
        if(isExploded) return;
        isExploded = true;
        bloomTarget = 15.0;
        uiEl.innerText = 'System: CORE_BREACH_DETECTED';
        gestureIndicator.innerText = 'BIG BANG';
        gestureIndicator.classList.add('active');
        gsap.to(bloomPass, { strength: bloomTarget, duration: 0.1, onComplete: () => { bloomTarget = 3.0; }});
    }

    function triggerReset() {
        if(!isExploded) return;
        isExploded = false;
        bloomTarget = 2.5;
        uiEl.innerText = 'System: Re-Sequencing_Data';
        gestureIndicator.innerText = 'CORE RESETTING';
        gestureIndicator.classList.add('active');
        setTimeout(() => {
            gestureIndicator.classList.remove('active');
            if(!isExploded) uiEl.innerText = 'System: Ready | Mode: Interactive_Core';
        }, 1500);
    }

    // --- TOUCH & MOUSE FALLBACK ---
    let touchStartX = 0, touchStartY = 0;

    document.addEventListener('mousemove', (e) => {
        inputX = (e.clientX / innerWidth - 0.5) * 4;
        inputY = (e.clientY / innerHeight - 0.5) * 4;
    });

    document.addEventListener('click', () => {
        isExploded ? triggerReset() : triggerExplosion();
    });

    document.addEventListener('touchstart', (e) => {
        touchStartX = e.touches[0].clientX;
        touchStartY = e.touches[0].clientY;
    });

    document.addEventListener('touchmove', (e) => {
        inputX = (e.touches[0].clientX / innerWidth - 0.5) * 4;
        inputY = (e.touches[0].clientY / innerHeight - 0.5) * 4;
    });

    document.addEventListener('touchend', (e) => {
        if (Math.abs(e.changedTouches[0].clientX - touchStartX) < 15 &&
            Math.abs(e.changedTouches[0].clientY - touchStartY) < 15) {
            isExploded ? triggerReset() : triggerExplosion();
        }
    });

    // --- HAND TRACKING (MediaPipe) ---
    const videoEl = document.getElementById('video');
    const previewEl = document.getElementById('webcam-preview');

    const hands = new Hands({ locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1675469240/${file}` });
    hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.7, minTrackingConfidence: 0.5 });

    hands.onResults((results) => {
        if (!results.multiHandLandmarks || results.multiHandLandmarks.length === 0) return;
        const landmarks = results.multiHandLandmarks[0];

        const indexTip = landmarks[8];
        inputX = (1 - indexTip.x - 0.5) * 4;
        inputY = (indexTip.y - 0.5) * 4;

        const wrist = landmarks[0];
        const fingerTips = [landmarks[4], landmarks[8], landmarks[12], landmarks[16], landmarks[20]];
        let avgDist = 0;
        for (const tip of fingerTips) avgDist += Math.sqrt((tip.x - wrist.x)**2 + (tip.y - wrist.y)**2 + (tip.z - wrist.z)**2);
        avgDist /= fingerTips.length;

        const spreadDelta = avgDist - prevPalmSpread;
        if (avgDist > PALM_OPEN_THRESHOLD && spreadDelta > 0.03 && !isExploded) triggerExplosion();
        else if (avgDist < FIST_THRESHOLD && isExploded) triggerReset();
        prevPalmSpread = avgDist;
    });

    const cameraConstraints = {
        video: {
            width: { ideal: 640 },
            height: { ideal: 480 },
            facingMode: "user"
        }
    };

    navigator.mediaDevices.getUserMedia(cameraConstraints)
        .then(stream => {
            previewEl.srcObject = stream;
            videoEl.srcObject = stream;
            videoEl.play();

            async function processVideo() {
                if (videoEl.readyState >= 2) {
                    await hands.send({ image: videoEl });
                }
                requestAnimationFrame(processVideo);
            }
            processVideo();

            document.getElementById('loading').classList.add('hidden');
        })
        .catch(err => {
            console.error("Camera geweigerd of niet gevonden:", err);
            document.getElementById('loading').innerHTML = `
                <div style="color:#ff4444;">CAMERA ACCESS DENIED</div>
                <div style="font-size:12px; margin-top:10px;">Touch screen to interact</div>
            `;
            setTimeout(() => document.getElementById('loading').classList.add('hidden'), 2000);
        });


    // --- ANIMATE ---
    const dummy = new THREE.Object3D();
    const clock = new THREE.Clock();

    function animate() {
        requestAnimationFrame(animate);
        const time = clock.getElapsedTime();

        const breathScale = 1.0 + Math.sin(time * 2.0) * 0.05;

        iMesh.rotation.y += 0.002;
        iMesh.rotation.x += 0.001;

        targetRotX += (inputX - targetRotX) * 0.05;
        targetRotY += (inputY - targetRotY) * 0.05;
        scene.rotation.y = targetRotX;
        scene.rotation.x = targetRotY;

        bloomPass.strength += (bloomTarget - bloomPass.strength) * 0.1;

        for (let i = 0; i < PARTICLE_COUNT; i++) {
            const p = particles[i];

            if (isExploded) {
                p.x += p.vx; p.y += p.vy; p.z += p.vz;
            } else {
                const targetX = p.origX * breathScale;
                const targetY = p.origY * breathScale;
                const targetZ = p.origZ * breathScale;

                p.x += (targetX - p.x) * 0.08;
                p.y += (targetY - p.y) * 0.08;
                p.z += (targetZ - p.z) * 0.08;
            }

            dummy.position.set(p.x, p.y, p.z);
            dummy.quaternion.copy(camera.quaternion);
            dummy.updateMatrix();
            iMesh.setMatrixAt(i, dummy.matrix);
        }

        iMesh.instanceMatrix.needsUpdate = true;
        composer.render();
    }

    window.addEventListener('resize', () => {
        camera.aspect = innerWidth / innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(innerWidth, innerHeight);
        composer.setSize(innerWidth, innerHeight);
    });

    animate();
</script>
</body>
</html>
